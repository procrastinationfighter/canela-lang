-- File generated by the BNF Converter (bnfc 2.9.4).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module SkelCanela where

import Prelude (($), Either(..), Eq, Ord, Integer, IO, Bool, String, (++), Show, show, Read, putStrLn)
import qualified AbsCanela

import Control.Monad.Identity
import Control.Monad.Error
import Control.Monad.Reader
import Control.Monad.State
import Control.Monad.Writer
import Data.Maybe

import qualified Data.Map as Map 

-- TODO: Lambdas shall be done at the end.
data Value 
    = Int Integer 
    | Str String 
    | Bool Bool 
    | UserType [Value] 
    | Fun AbsCanela.Type [AbsCanela.Type] AbsCanela.Block Env 
    | Enum EnumMap
  deriving (Eq, Ord, Show, Read)
type Loc = Integer
type Mem = Map.Map Loc Value
type Var = (AbsCanela.AccessType, Loc)
type Env = Map.Map AbsCanela.Ident Var
type EnumMap = Map.Map AbsCanela.Ident [AbsCanela.Type]

type Run a = ReaderT Env (ErrorT String (StateT Mem IO)) a
type Result a = Run a

failure :: Show a => a -> Result ()
failure x = do throwError $ "Undefined case: " ++ show x;
               return ();
{-
transIdent :: AbsCanela.Ident -> Result
transIdent x = case x of
  AbsCanela.Ident string -> failure x
-}

interpret :: Show a => AbsCanela.Program' a -> IO()
interpret program = do
  x <- runStateT (runErrorT (runReaderT monad Map.empty)) Map.empty
  case x of
    ((Left err), _) -> putStrLn err
    _ -> return ()
    where
      monad = transProgram program

transProgram :: Show a => AbsCanela.Program' a -> Result ()
transProgram x = case x of
  AbsCanela.Program _ topdefs -> failure x

transTopDef :: Show a => AbsCanela.TopDef' a -> Result ()
transTopDef x = case x of
  AbsCanela.FnDef _ type_ ident args block -> failure x
  AbsCanela.EnDef _ ident envardefs -> failure x

transArg :: Show a => AbsCanela.Arg' a -> Result ()
transArg x = case x of
  AbsCanela.Arg _ accesstype type_ ident -> failure x

transEnVarDef :: Show a => AbsCanela.EnVarDef' a -> Result ()
transEnVarDef x = case x of
  AbsCanela.EnVarDef _ ident types -> failure x

transBlock :: Show a => AbsCanela.Block' a -> Result ()
transBlock x = case x of
  AbsCanela.Block _ stmts -> failure x

transStmt :: Show a => AbsCanela.Stmt' a -> Result ()
transStmt x = case x of
  AbsCanela.Empty _ -> failure x
  AbsCanela.BStmt _ block -> failure x
  AbsCanela.Decl _ accesstype type_ items -> failure x
  AbsCanela.Ass _ ident expr -> failure x
  AbsCanela.Incr _ ident -> failure x
  AbsCanela.Decr _ ident -> failure x
  AbsCanela.Ret _ expr -> failure x
  AbsCanela.VRet _ -> failure x
  AbsCanela.Cond _ expr block -> failure x
  AbsCanela.CondElse _ expr block1 block2 -> failure x
  AbsCanela.Match _ expr matchbranchs -> failure x
  AbsCanela.While _ expr stmt -> failure x
  AbsCanela.For _ ident expr1 expr2 block -> failure x
  AbsCanela.SExp _ expr -> failure x

transItem :: Show a => AbsCanela.Item' a -> Result ()
transItem x = case x of
  AbsCanela.NoInit _ ident -> failure x
  AbsCanela.Init _ ident expr -> failure x

transMatchBranch :: Show a => AbsCanela.MatchBranch' a -> Result ()
transMatchBranch x = case x of
  AbsCanela.MatchBr _ matchvar block -> failure x

transMatchVar :: Show a => AbsCanela.MatchVar' a -> Result ()
transMatchVar x = case x of
  AbsCanela.MatchVar _ ident1 ident2 idents -> failure x
  AbsCanela.MatchDefault _ -> failure x

transType :: Show a => AbsCanela.Type' a -> Result ()
transType x = case x of
  AbsCanela.Int _ -> failure x
  AbsCanela.Str _ -> failure x
  AbsCanela.Bool _ -> failure x
  AbsCanela.Void _ -> failure x
  AbsCanela.Func _ -> failure x
  AbsCanela.UserType _ ident -> failure x
  AbsCanela.Fun _ type_ types -> failure x

transAccessType :: Show a => AbsCanela.AccessType' a -> Result ()
transAccessType x = case x of
  AbsCanela.Const _ -> failure x
  AbsCanela.Mutable _ -> failure x

transExpr :: Show a => AbsCanela.Expr' a -> Result ()
transExpr x = case x of
  AbsCanela.ELambda _ args block -> failure x
  AbsCanela.EEnum _ ident1 ident2 exprs -> failure x
  AbsCanela.EVar _ ident -> failure x
  AbsCanela.ELitInt _ integer -> failure x
  AbsCanela.ELitTrue _ -> failure x
  AbsCanela.ELitFalse _ -> failure x
  AbsCanela.EApp _ ident exprs -> failure x
  AbsCanela.EString _ string -> failure x
  AbsCanela.Neg _ expr -> failure x
  AbsCanela.Not _ expr -> failure x
  AbsCanela.EMul _ expr1 mulop expr2 -> failure x
  AbsCanela.EAdd _ expr1 addop expr2 -> failure x
  AbsCanela.ERel _ expr1 relop expr2 -> failure x
  AbsCanela.EAnd _ expr1 expr2 -> failure x
  AbsCanela.EOr _ expr1 expr2 -> failure x

transAddOp :: Show a => AbsCanela.AddOp' a -> Result ()
transAddOp x = case x of
  AbsCanela.Plus _ -> failure x
  AbsCanela.Minus _ -> failure x

transMulOp :: Show a => AbsCanela.MulOp' a -> Result ()
transMulOp x = case x of
  AbsCanela.Times _ -> failure x
  AbsCanela.Div _ -> failure x
  AbsCanela.Mod _ -> failure x

transRelOp :: Show a => AbsCanela.RelOp' a -> Result ()
transRelOp x = case x of
  AbsCanela.LTH _ -> failure x
  AbsCanela.LE _ -> failure x
  AbsCanela.GTH _ -> failure x
  AbsCanela.GE _ -> failure x
  AbsCanela.EQU _ -> failure x
  AbsCanela.NE _ -> failure x
